# -*- coding: utf-8 -*-
"""ForeSense.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uEF2W8nKv3g8IQ-LCBaCf_9i3aQUU4PW
"""

import pandas as pd

data_sclad = pd.read_csv('/content/Продажи со складов 41175635.csv')

data_sclad.head(30)

import pandas as pd
import plotly.graph_objs as go
import plotly.subplots as sp

# Загружаем файл построчно
file_path = 'Продажи со складов 41175635.csv'
with open(file_path, 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Пропускаем первую строку (заголовок с датами, но некорректен)
data_lines = lines[1:]

# Парсим строки
parsed_data = []
for line in data_lines:
    parts = line.strip().split(';')
    warehouse = parts[0]
    values = parts[1:]
    for i in range(0, len(values) - 1, 2):
        date_index = i // 2
        sales = values[i]
        stock = values[i + 1]
        parsed_data.append((warehouse, date_index, sales, stock))

# Создаём DataFrame
df = pd.DataFrame(parsed_data, columns=['Склад', 'Индекс_даты', 'Продажи', 'Остатки'])
df['Индекс_даты'] = df['Индекс_даты'].astype(int)
df['Продажи'] = pd.to_numeric(df['Продажи'], errors='coerce')
df['Остатки'] = pd.to_numeric(df['Остатки'], errors='coerce')

# Создаём интерактивные графики
fig = sp.make_subplots(rows=2, cols=1, shared_xaxes=True, subplot_titles=("Продажи", "Остатки"))

# Добавляем линии по складам
for склад in df['Склад'].unique():
    subset = df[df['Склад'] == склад]
    fig.add_trace(
        go.Scatter(x=subset['Индекс_даты'], y=subset['Продажи'], mode='lines', name=f'{склад} продажи'),
        row=1, col=1
    )
    fig.add_trace(
        go.Scatter(x=subset['Индекс_даты'], y=subset['Остатки'], mode='lines', name=f'{склад} остатки'),
        row=2, col=1
    )

# Обновляем макет
fig.update_layout(height=1200, width=2000, title_text="Интерактивная динамика по складам")
fig.show()

import pandas as pd
import matplotlib.pyplot as plt

# Загрузка файла
file_path = "WB - 41175635 - Продажи и остатки - 01.09.2021-17.04.2025 - (18.04.2025).csv"
df = pd.read_csv(file_path, sep=';')

# Преобразование столбцов
df['Дата'] = pd.to_datetime(df['Дата'], errors='coerce')
df['Продажи, кол-во'] = pd.to_numeric(df['Продажи, кол-во'], errors='coerce')
df['Выручка'] = pd.to_numeric(df['Выручка'], errors='coerce')

# Оставляем только нужные и очищаем от пропусков
df_clean = df[['Дата', 'Продажи, кол-во', 'Выручка']].dropna()
df_clean = df_clean.sort_values('Дата').reset_index(drop=True)

# Визуализация динамики продаж
plt.figure(figsize=(14, 5))
plt.plot(df_clean['Дата'], df_clean['Продажи, кол-во'], label='Продажи, кол-во')
plt.title('Исторические продажи')
plt.xlabel('Дата')
plt.ylabel('Количество продаж')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Если df_clean уже есть, просто добавим столбец цены за единицу
df_clean['Цена за единицу'] = df_clean['Выручка'] / df_clean['Продажи, кол-во']

# График: зависимость количества продаж от цены
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Цена за единицу', y='Продажи, кол-во', data=df_clean)
plt.title('Зависимость количества продаж от цены за единицу')
plt.xlabel('Цена за единицу (руб.)')
plt.ylabel('Количество продаж')
plt.grid(True)
plt.tight_layout()
plt.show()

print(df_clean.describe())
print(df_clean.corr(numeric_only=True))

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Предполагается, что df_clean уже создан, и содержит колонки:
# 'Продажи, кол-во', 'Выручка', 'Цена за единицу'

# Статистика
print("Описательная статистика:")
print(df_clean.describe())

# Корреляционная матрица
corr_matrix = df_clean.corr(numeric_only=True)

# Тепловая карта
plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Корреляции между числовыми признаками')
plt.tight_layout()
plt.show()

df_clean['Месяц'] = df_clean['Дата'].dt.month
df_clean['День недели'] = df_clean['Дата'].dt.dayofweek

plt.figure(figsize=(10, 5))
sns.boxplot(x='Месяц', y='Продажи, кол-во', data=df_clean)
plt.title('Продажи по месяцам')
plt.show()

df_clean['7дн_скользящее'] = df_clean['Продажи, кол-во'].rolling(window=7).mean()

plt.figure(figsize=(14, 6))
plt.plot(df_clean['Дата'], df_clean['Продажи, кол-во'], label='Фактические продажи', alpha=0.5)
plt.plot(df_clean['Дата'], df_clean['7дн_скользящее'], label='Скользящее среднее (7 дней)', color='red')
plt.legend()
plt.title('Продажи и тренд')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# === Загрузка и парсинг файла ===
file_path = "Продажи со складов 41175635.csv"
with open(file_path, 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Извлечение дат из первой строки
raw_dates = lines[0].strip().split(';')
dates = [d for d in raw_dates if '-' in d]

# Парсинг строк, пропуская заголовки
parsed_data = []
for line in lines[1:]:
    parts = line.strip().split(';')
    warehouse = parts[0]
    values = parts[1:]
    for i in range(0, len(values) - 1, 2):
        date_index = i // 2
        if date_index < len(dates):
            sales = values[i]
            stock = values[i + 1]
            parsed_data.append((warehouse, dates[date_index], sales, stock))

# === Создание датафрейма ===
df_wh = pd.DataFrame(parsed_data, columns=['Склад', 'Дата', 'Продажи', 'Остатки'])
df_wh = df_wh[df_wh['Склад'] != 'Склад']  # удаляем повторяющиеся заголовки

# Преобразование типов
df_wh['Дата'] = pd.to_datetime(df_wh['Дата'], format="%d-%m", errors='coerce')
df_wh['Продажи'] = pd.to_numeric(df_wh['Продажи'], errors='coerce')
df_wh['Остатки'] = pd.to_numeric(df_wh['Остатки'], errors='coerce')

# === Агрегация: суммарные продажи по складам ===
pivot = df_wh.groupby('Склад')['Продажи'].sum().sort_values(ascending=False)

# Фильтрация: только склады с ненулевыми продажами
pivot_filtered = pivot[pivot > 0]

# === Визуализация ===
plt.figure(figsize=(12, 6))
pivot_filtered.plot(kind='bar')
plt.title('Суммарные продажи по складам (только где есть продажи)')
plt.ylabel('Продажи')
plt.xlabel('Склад')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y')
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# === Группировка: суммарные продажи по складам ===
sales_by_warehouse = df_wh.groupby('Склад', as_index=False)['Продажи'].sum()
sales_by_warehouse = sales_by_warehouse[sales_by_warehouse['Продажи'] > 0]
sales_by_warehouse = sales_by_warehouse.sort_values(by='Продажи', ascending=False)

# === Построение графика ===
plt.figure(figsize=(12, 6))
plt.bar(sales_by_warehouse['Склад'], sales_by_warehouse['Продажи'])
plt.title('Суммарные продажи по складам')
plt.xlabel('Склад')
plt.ylabel('Продажи')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y')
plt.tight_layout()
plt.show()

import plotly.graph_objects as go

# Подготовка
sales_by_warehouse = df_wh.groupby('Склад', as_index=False)['Продажи'].sum()
sales_by_warehouse = sales_by_warehouse[sales_by_warehouse['Продажи'] > 0]
sales_by_warehouse = sales_by_warehouse.sort_values(by='Продажи', ascending=False)
sales_by_warehouse = sales_by_warehouse.reset_index(drop=True)
sales_by_warehouse.index += 1

# Создание таблицы
fig = go.Figure(data=[go.Table(
    header=dict(values=['#', 'Склад', 'Продажи'], fill_color='lightgray', align='left'),
    cells=dict(values=[
        sales_by_warehouse.index,
        sales_by_warehouse['Склад'],
        sales_by_warehouse['Продажи']
    ],
    align='left'))
])

fig.update_layout(title='Суммарные Продажи По Складам')
fig.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# === 1. Загрузка и парсинг данных ===
file_path = "Продажи со складов 41175635.csv"
with open(file_path, 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Получаем даты
raw_dates = lines[0].strip().split(';')
dates = [d for d in raw_dates if '-' in d]
date_map = pd.Series(pd.to_datetime(dates, format='%d-%m', errors='coerce'))

# Парсинг строк
parsed_data = []
for line in lines[1:]:
    parts = line.strip().split(';')
    warehouse = parts[0]
    values = parts[1:]
    for i in range(0, len(values) - 1, 2):
        index = i // 2
        if index < len(date_map):
            sales = values[i]
            stock = values[i + 1]
            parsed_data.append((warehouse, index, date_map[index], sales, stock))

# === 2. Создание DataFrame ===
df_wh = pd.DataFrame(parsed_data, columns=['Склад', 'Индекс_даты', 'Дата', 'Продажи', 'Остатки'])
df_wh = df_wh[df_wh['Склад'] != 'Склад']  # убираем повтор заголовков
df_wh['Продажи'] = pd.to_numeric(df_wh['Продажи'], errors='coerce')
df_wh['Остатки'] = pd.to_numeric(df_wh['Остатки'], errors='coerce')

# === 3. Добавление дня недели и месяца ===
df_wh['День недели'] = df_wh['Дата'].dt.dayofweek
df_wh['Месяц'] = df_wh['Дата'].dt.month

# === 4. Корреляции по складам ===
corrs = []
for склад, group in df_wh.groupby('Склад'):
    if group['Продажи'].notna().sum() > 10:
        corr_w = group[['Продажи', 'День недели']].corr().iloc[0, 1]
        corr_m = group[['Продажи', 'Месяц']].corr().iloc[0, 1]
        corrs.append({'Склад': склад, 'День недели': corr_w, 'Месяц': corr_m})

df_corrs = pd.DataFrame(corrs).set_index('Склад')

# === 5. Построение тепловой карты ===
plt.figure(figsize=(12, 8))
sns.heatmap(df_corrs, annot=True, cmap='coolwarm', center=0, linewidths=0.5)
plt.title('Корреляция между продажами и календарем по складам')
plt.tight_layout()
plt.show()

import pandas as pd

# Предполагается, что df_wh уже создан и содержит колонки:
# 'Склад', 'Продажи'

# === Группировка и расчёт метрик ===
summary_stats = df_wh.groupby('Склад').agg({
    'Продажи': [
        'mean',                        # средняя продажа
        'std',                         # стандартное отклонение
        lambda x: (x == 0).mean()      # доля нулевых продаж
    ]
}).reset_index()

# Переименование колонок
summary_stats.columns = ['Склад', 'Средняя продажа', 'Стандартное отклонение', 'Доля нулевых продаж']

# Сортировка по стандартному отклонению (можно менять на другие столбцы)
summary_stats = summary_stats.sort_values(by='Стандартное отклонение', ascending=False)

# Отображение результата
print(summary_stats)

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# === Параметры ===
склад = 'Коледино WB'  # ← можешь заменить на другой

# === Подготовка данных ===
df_sklad = df_wh[df_wh['Склад'] == склад].copy()
df_sklad = df_sklad.dropna(subset=['Дата', 'Продажи']).sort_values('Дата')
df_sklad['Дата_число'] = (df_sklad['Дата'] - df_sklad['Дата'].min()).dt.days

# === Обучение модели ===
X = df_sklad[['Дата_число']]
y = df_sklad['Продажи']
model = LinearRegression().fit(X, y)
df_sklad['Тренд'] = model.predict(X)

# === Визуализация ===
plt.figure(figsize=(14, 6))
plt.plot(df_sklad['Дата'], df_sklad['Продажи'], label='Фактические продажи', alpha=0.6)
plt.plot(df_sklad['Дата'], df_sklad['Тренд'], label='Линейный тренд', color='red')
plt.title(f'Линейный тренд по складу: {склад}')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# === Коэффициент наклона ===
коэффициент = model.coef_[0]
print(f"Коэффициент наклона тренда для {склад}: {коэффициент:.2f}")

# === Интерпретация ===
if коэффициент > 0:
    print("🔼 Продажи растут со временем (в среднем).")
elif коэффициент < 0:
    print("🔽 Продажи снижаются со временем.")
else:
    print("➖ Продажи стабильны (нет выраженного тренда).")

import pandas as pd
from sklearn.linear_model import LinearRegression

# Список для результатов
trend_data = []

# Проходим по каждому складу
for склад, group in df_wh.groupby('Склад'):
    group = group.dropna(subset=['Дата', 'Продажи']).sort_values('Дата')
    if len(group) >= 10:
        group['Дата_число'] = (group['Дата'] - group['Дата'].min()).dt.days
        X = group[['Дата_число']]
        y = group['Продажи']

        try:
            model = LinearRegression().fit(X, y)
            коэф = model.coef_[0]

            if коэф > 0.5:
                интерпретация = 'Продажи растут'
            elif коэф < -0.5:
                интерпретация = 'Продажи падают'
            else:
                интерпретация = 'Продажи стабильны'

            trend_data.append({
                'Склад': склад,
                'Коэффициент наклона': round(коэф, 2),
                'Интерпретация': интерпретация
            })
        except:
            pass  # пропускаем склад, если ошибка в модели

# В DataFrame
df_trends = pd.DataFrame(trend_data).sort_values(by='Коэффициент наклона', ascending=False)
print(df_trends)

"""Приступаем к прогнозированию

"""

print(sales_long.columns)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

# === 1. Загрузка и парсинг данных продаж ===
file_path = "Продажи со складов 41175635.csv"
with open(file_path, 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Получаем даты из первой строки
raw_dates = lines[0].strip().split(';')
dates = [d for d in raw_dates if '-' in d]

# Автоматическое определение года
parsed_dates = []
current_year = 2021
last_month = 0

for d in dates:
    day, month = map(int, d.split('-'))
    if last_month == 12 and month == 1:
        current_year += 1
    try:
        dt = datetime(current_year, month, day)
        parsed_dates.append(dt)
        last_month = month
    except ValueError:
        parsed_dates.append(None)

date_map = pd.Series(parsed_dates)

# Парсинг строк
parsed_data = []
for line in lines[1:]:
    parts = line.strip().split(';')
    warehouse = parts[0]
    values = parts[1:]
    for i in range(0, len(values) - 1, 2):  # шаг 2: Продажи / Остатки
        index = i // 2
        if index < len(date_map):
            sales = values[i]
            stock = values[i + 1]
            parsed_data.append((warehouse, index, date_map[index], sales, stock))

# === 2. Создание DataFrame по складам ===
df_wh = pd.DataFrame(parsed_data, columns=['Склад', 'Индекс_даты', 'Дата', 'Продажи', 'Остатки'])
df_wh = df_wh[df_wh['Склад'] != 'Склад']  # убираем заголовок
df_wh['Продажи'] = pd.to_numeric(df_wh['Продажи'], errors='coerce')
df_wh['Остатки'] = pd.to_numeric(df_wh['Остатки'], errors='coerce')

# Убираем строки без даты
df_wh = df_wh[df_wh['Дата'].notna()]

# === 3. Добавление временных признаков ===
df_wh['День недели'] = df_wh['Дата'].dt.dayofweek
df_wh['Месяц'] = df_wh['Дата'].dt.month

# === 4. Загрузка погодных данных ===
weather_df = pd.read_csv("moscow.csv")
weather_df["date"] = pd.to_datetime(weather_df["date"])

# === 5. Оставляем только нужные склады ===
target_warehouses = ['Коледино WB', 'Электросталь WB']
df_filtered = df_wh[df_wh['Склад'].isin(target_warehouses)].copy()

# === 6. Объединение с температурой ===
df_final = df_filtered.merge(weather_df[['date', 'tavg', 'prcp']], left_on='Дата', right_on='date', how='left')
df_final.drop(columns='date', inplace=True)

# === 7. Просмотр результата ===
print(df_final.head())

# (опционально) Сохранить итоговый файл
# df_final.to_csv("итог_продажи_температура.csv", index=False)

import seaborn as sns
import matplotlib.pyplot as plt

# === 1. График зависимости продаж от температуры по каждому складу ===
for warehouse in df_final['Склад'].unique():
    subset = df_final[df_final['Склад'] == warehouse]

    plt.figure(figsize=(10, 5))
    sns.scatterplot(data=subset, x='tavg', y='Продажи', alpha=0.5)
    plt.title(f'Зависимость продаж от температуры: {warehouse}')
    plt.xlabel('Средняя температура (°C)')
    plt.ylabel('Продажи')
    plt.grid(True)
    plt.show()

# === 2. Корреляция по каждому складу ===
for warehouse in df_final['Склад'].unique():
    subset = df_final[df_final['Склад'] == warehouse]
    correlation = subset[['Продажи', 'tavg']].corr().iloc[0, 1]
    print(f"Корреляция между температурой и продажами для склада {warehouse}: {correlation:.3f}")

import seaborn as sns
import matplotlib.pyplot as plt

# Выбираем только числовые переменные для анализа
corr_features = ['Продажи', 'tavg', 'Остатки', 'День недели', 'Месяц']
corr_matrix = df_final[corr_features].corr()

# Визуализация
plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', vmin=-1, vmax=1)
plt.title('Корреляционная матрица признаков')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

# === 1. Загрузка и парсинг данных продаж ===
file_path = "Продажи со складов 41175635.csv"
with open(file_path, 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Получаем даты из первой строки
raw_dates = lines[0].strip().split(';')
dates = [d for d in raw_dates if '-' in d]

# Автоматическое определение года
parsed_dates = []
current_year = 2021
last_month = 0

for d in dates:
    day, month = map(int, d.split('-'))
    if last_month == 12 and month == 1:
        current_year += 1
    try:
        dt = datetime(current_year, month, day)
        parsed_dates.append(dt)
        last_month = month
    except ValueError:
        parsed_dates.append(None)

date_map = pd.Series(parsed_dates)

# Парсинг строк
parsed_data = []
for line in lines[1:]:
    parts = line.strip().split(';')
    warehouse = parts[0]
    values = parts[1:]
    for i in range(0, len(values) - 1, 2):  # шаг 2: Продажи / Остатки
        index = i // 2
        if index < len(date_map):
            sales = values[i]
            stock = values[i + 1]
            parsed_data.append((warehouse, index, date_map[index], sales, stock))

# === 2. Создание DataFrame по складам ===
df_wh = pd.DataFrame(parsed_data, columns=['Склад', 'Индекс_даты', 'Дата', 'Продажи', 'Остатки'])
df_wh = df_wh[df_wh['Склад'] != 'Склад']  # убираем заголовок
df_wh['Продажи'] = pd.to_numeric(df_wh['Продажи'], errors='coerce')
df_wh['Остатки'] = pd.to_numeric(df_wh['Остатки'], errors='coerce')

# Убираем строки без даты
df_wh = df_wh[df_wh['Дата'].notna()]

# === 3. Добавление временных признаков ===
df_wh['День недели'] = df_wh['Дата'].dt.dayofweek
df_wh['Месяц'] = df_wh['Дата'].dt.month

# === 4. Загрузка погодных данных ===
weather_df = pd.read_csv("kazan.csv")
weather_df["date"] = pd.to_datetime(weather_df["date"])

# === 5. Оставляем только нужные склады ===
target_warehouses = ['Казань WB']
df_filtered = df_wh[df_wh['Склад'].isin(target_warehouses)].copy()

# === 6. Объединение с температурой ===
df_final = df_filtered.merge(weather_df[['date', 'tavg', 'prcp']], left_on='Дата', right_on='date', how='left')
df_final.drop(columns='date', inplace=True)

# === 7. Просмотр результата ===
print(df_final.head())

# (опционально) Сохранить итоговый файл
# df_final.to_csv("итог_продажи_температура.csv", index=False)

import seaborn as sns
import matplotlib.pyplot as plt

# === 1. График зависимости продаж от температуры по каждому складу ===
for warehouse in df_final['Склад'].unique():
    subset = df_final[df_final['Склад'] == warehouse]

    plt.figure(figsize=(10, 5))
    sns.scatterplot(data=subset, x='tavg', y='Продажи', alpha=0.5)
    plt.title(f'Зависимость продаж от температуры: {warehouse}')
    plt.xlabel('Средняя температура (°C)')
    plt.ylabel('Продажи')
    plt.grid(True)
    plt.show()

# === 2. Корреляция по каждому складу ===
for warehouse in df_final['Склад'].unique():
    subset = df_final[df_final['Склад'] == warehouse]
    correlation = subset[['Продажи', 'tavg']].corr().iloc[0, 1]
    print(f"Корреляция между температурой и продажами для склада {warehouse}: {correlation:.3f}")

import seaborn as sns
import matplotlib.pyplot as plt

# Выбираем только числовые переменные для анализа
corr_features = ['Продажи', 'tavg', 'Остатки', 'День недели', 'Месяц']
corr_matrix = df_final[corr_features].corr()

# Визуализация
plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', vmin=-1, vmax=1)
plt.title('Корреляционная матрица признаков')
plt.show()

df_final['prcp']=df_final['prcp'].fillna(0)

import seaborn as sns
import matplotlib.pyplot as plt

# === 1. График зависимости продаж от температуры по каждому складу ===
for warehouse in df_final['Склад'].unique():
    subset = df_final[df_final['Склад'] == warehouse]

    plt.figure(figsize=(10, 5))
    sns.scatterplot(data=subset, x='prcp', y='Продажи', alpha=0.5)
    plt.title(f'Зависимость продаж от осадков: {warehouse}')
    plt.xlabel('Средняя температура (°C)')
    plt.ylabel('Продажи')
    plt.grid(True)
    plt.show()

# === 2. Корреляция по каждому складу ===
for warehouse in df_final['Склад'].unique():
    subset = df_final[df_final['Склад'] == warehouse]
    correlation = subset[['Продажи', 'prcp']].corr().iloc[0, 1]
    print(f"Корреляция между температурой и продажами для склада {warehouse}: {correlation:.3f}")

import matplotlib.pyplot as plt
import pandas as pd

# Убедимся, что дата в нужном формате
df_final['Дата'] = pd.to_datetime(df_final['Дата'])

# Заменим NaN в осадках на 0
df_final['prsr'] = df_final['prcp'].fillna(0)

# Фильтрация по складу
df_kol = df_final[df_final['Склад'] == 'Казань WB']

# Построение графика
fig, ax1 = plt.subplots(figsize=(12, 6))

# Продажи
ax1.plot(df_kol['Дата'], df_kol['Продажи'], color='blue', label='Продажи', marker='o')
ax1.set_xlabel('Дата')
ax1.set_ylabel('Продажи', color='blue')
ax1.tick_params(axis='y', labelcolor='blue')

# Осадки (вторая ось)
ax2 = ax1.twinx()
ax2.plot(df_kol['Дата'], df_kol['prcp'], color='green', label='Осадки (prcp)', marker='x')
ax2.set_ylabel('Осадки (mm)', color='green')
ax2.tick_params(axis='y', labelcolor='green')

# Заголовок и оформление
plt.title('Динамика продаж и осадков')
fig.tight_layout()
plt.grid(True)

df_kol.head(20)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from math import sqrt
from sklearn.metrics import mean_absolute_error, mean_squared_error

# === 1. Подготовка данных ===
df = df_kol.copy()
df = df.sort_values('Дата')
df = df.set_index('Дата')
df = df.asfreq('D').fillna(0)

y = df['Продажи']
split_idx = int(len(y) * 0.8)
y_train, y_test = y[:split_idx], y[split_idx:]

# === 2. Функция визуализации ===
def plot_forecast_full(y_train, y_test, y_pred, title):
    plt.figure(figsize=(14, 5))

    # Факт
    plt.plot(y_train.index, y_train.values, label='Факт (train)', color='blue')
    plt.plot(y_test.index, y_test.values, label='Факт (test)', color='blue', linestyle='--')

    # Прогноз (только на test)
    plt.plot(y_test.index, y_pred, label='Прогноз', color='orange', linestyle='--', marker='x')

    # Линия раздела
    plt.axvline(x=y_test.index[0], color='black', linestyle=':', label='Начало прогноза')

    plt.title(title)
    plt.xlabel('Дата')
    plt.ylabel('Продажи')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Прогноз
y_pred_naive = [y_train.iloc[-1]] * len(y_test)

# Метрики
mae = mean_absolute_error(y_test, y_pred_naive)
rmse = sqrt(mean_squared_error(y_test, y_pred_naive))
mape = np.mean(np.abs((y_test - y_pred_naive) / y_test.replace(0, np.nan))) * 100
print(f"Naive → MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")

# График
plot_forecast_full(y_train, y_test, y_pred_naive, 'Naive Forecast')

from statsmodels.tsa.arima.model import ARIMA

model = ARIMA(y_train, order=(5, 1, 0))
model_fit = model.fit()
y_pred_arima = model_fit.forecast(steps=len(y_test))

mae = mean_absolute_error(y_test, y_pred_arima)
rmse = sqrt(mean_squared_error(y_test, y_pred_arima))
mape = np.mean(np.abs((y_test - y_pred_arima) / y_test.replace(0, np.nan))) * 100
print(f"ARIMA → MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")
plot_forecast_full(y_train, y_test, y_pred_arima, 'ARIMA Forecast')

from prophet import Prophet

# Подготовка
df_prophet = y.reset_index()
df_prophet.columns = ['ds', 'y']
model = Prophet()
model.fit(df_prophet.iloc[:split_idx])

future = model.make_future_dataframe(periods=len(y_test))
forecast = model.predict(future)

y_pred_prophet = forecast['yhat'].iloc[split_idx:].values
y_true_prophet = df_prophet['y'].iloc[split_idx:].values
y_test_prophet = pd.Series(y_true_prophet, index=y_test.index)

mae = mean_absolute_error(y_true_prophet, y_pred_prophet)
rmse = sqrt(mean_squared_error(y_true_prophet, y_pred_prophet))
mape = np.mean(np.abs((y_true_prophet - y_pred_prophet) / np.where(y_true_prophet == 0, np.nan, y_true_prophet))) * 100
print(f"Prophet → MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")
y_test_prophet = pd.Series(y_true_prophet, index=y_test.index)
plot_forecast_full(y_train, y_test_prophet, y_pred_prophet, 'Prophet Forecast')

from sklearn.ensemble import RandomForestRegressor

# Создаём лаги
df_features = df[['Продажи', 'tavg', 'prcp']].copy()
for lag in range(1, 8):
    df_features[f'lag_{lag}'] = df_features['Продажи'].shift(lag)

df_features = df_features.dropna()

X = df_features.drop(columns='Продажи')
y = df_features['Продажи']

split_idx = int(len(X) * 0.8)
X_train, X_test = X[:split_idx], X[split_idx:]
y_train, y_test = y[:split_idx], y[split_idx:]

rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)
y_pred_rf = rf.predict(X_test)

mae = mean_absolute_error(y_test, y_pred_rf)
rmse = sqrt(mean_squared_error(y_test, y_pred_rf))
mape = np.mean(np.abs((y_test - y_pred_rf) / np.where(y_test == 0, np.nan, y_test))) * 100
print(f"RandomForest → MAE: {mae:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")

plot_forecast_full(y_train, y_test, y_pred_rf, 'RandomForest Forecast')

"""📊 Что значат метрики RandomForest:
✅ MAE (Mean Absolute Error): 15.13
→ В среднем модель ошибается на 15 продаж в каждом прогнозируемом дне.

✅ RMSE (Root Mean Squared Error): 34.10
→ Ошибка с учётом «штрафа» за крупные промахи. Модель иногда ошибается значительно — на 30+ штук.

⚠️ MAPE (Mean Absolute Percentage Error): 286.01%
→ Это значит, что в среднем модель ошибается более чем на 286% от фактического значения. Это очень много.

💡 Почему такой высокий MAPE?
Потому что в данных много нулей или малых значений:

python
Copy
Edit
df_kol1['Продажи'].describe()
Если, например:

факт = 3, а предсказано 12, то:

MAPE
=
∣
12
−
3
3
∣
=
3
⇒
300
%
MAPE=
​
  
3
12−3
​
  
​
 =3⇒300%
Также:

при факте = 0 возникает деление на ноль → это исключается .replace(0, np.nan), но искажает среднее.

✅ Что делать:
Сравни MAPE и MAE. Если MAPE высокий, а MAE разумный — модель не так плоха, просто в данных мало продаж или много нулей.

Попробуй SMAPE или MAE/RMSE — они более устойчивы к нулям.

Визуально проверь график: если форма тренда ок, значит модель «чувствует» данные.
"""

from datetime import timedelta
import numpy as np

# Подготовка данных
df_all = df_kol.copy().sort_values('Дата').set_index('Дата').asfreq('D').fillna(0)
weather = weather_df.set_index('date').sort_index().asfreq('D').fillna(method='ffill')

# Train до 1 марта
train_cutoff = pd.to_datetime('2025-03-01')
df_train = df_all[df_all.index < train_cutoff].copy()

# Обучение модели
df_features = df_train[['Продажи', 'tavg', 'prcp']].copy()
for lag in range(1, 8):
    df_features[f'lag_{lag}'] = df_features['Продажи'].shift(lag)
df_features.dropna(inplace=True)

X_train = df_features.drop(columns='Продажи')
y_train = df_features['Продажи']

rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# Начальные лаги = последние 7 дней февраля
last_known = df_all.loc[:train_cutoff - timedelta(days=1)].tail(7)['Продажи'].tolist()

# Прогноз на март
forecast_dates = pd.date_range('2025-03-01', '2025-03-31')
predictions = []

for date in forecast_dates:
    row = {
        'tavg': weather.loc[date, 'tavg'] if date in weather.index else 0,
        'prcp': weather.loc[date, 'prcp'] if date in weather.index else 0,
    }
    for i in range(1, 8):
        row[f'lag_{i}'] = last_known[-i]

    X_input = pd.DataFrame([row])
    y_pred = rf.predict(X_input)[0]
    predictions.append((date, y_pred))

    # Обновляем лаги: добавляем только предсказание
    last_known.append(y_pred)

# Финальный прогноз
df_forecast = pd.DataFrame(predictions, columns=['Дата', 'Прогноз'])
df_forecast.set_index('Дата', inplace=True)

# Сравнение с фактами
df_compare = df_all.loc['2025-03-01':'2025-03-31'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

# Метрики
from sklearn.metrics import mean_absolute_error, mean_squared_error
mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"Прогноз на март 2025 → MAE: {mae:.2f}, RMSE: {rmse:.2f}")

# График
plt.figure(figsize=(14, 5))
plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз', linestyle='--', marker='x')
plt.axvline(pd.to_datetime('2025-03-01'), color='black', linestyle=':', label='Старт прогноза')
plt.title('Прогноз продаж на март 2025 (RandomForest + лаги + погода)')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import numpy as np
from datetime import timedelta

def plot_forecast_compare(df_compare, title):
    plt.figure(figsize=(14, 5))
    plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
    plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз', linestyle='--', marker='x')
    plt.axvline(pd.to_datetime('2025-03-01'), color='black', linestyle=':', label='Старт прогноза')
    plt.title(title)
    plt.xlabel('Дата')
    plt.ylabel('Продажи')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

df_all = df_kol.copy().sort_values('Дата').set_index('Дата').asfreq('D').fillna(0)

# Обучение до марта
cutoff = pd.to_datetime('2025-03-01')
df_train = df_all[df_all.index < cutoff].copy()
weather = weather_df.set_index('date').asfreq('D').fillna(method='ffill')

# Создание лагов
df_feat = df_train[['Продажи']].copy()
for lag in range(1, 8):
    df_feat[f'lag_{lag}'] = df_feat['Продажи'].shift(lag)
df_feat.dropna(inplace=True)

X_train = df_feat.drop(columns='Продажи')
y_train = df_feat['Продажи']
rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# Прогноз
last_lags = df_train['Продажи'].iloc[-7:].tolist()
forecast_dates = pd.date_range('2025-03-01', '2025-03-31')
preds = []

for d in forecast_dates:
    row = {f'lag_{i}': last_lags[-i] for i in range(1, 8)}
    X_input = pd.DataFrame([row])
    y_pred = rf.predict(X_input)[0]
    preds.append((d, y_pred))
    last_lags.append(y_pred)

df_forecast = pd.DataFrame(preds, columns=['Дата', 'Прогноз']).set_index('Дата')
df_compare = df_all.loc['2025-03-01':'2025-03-31'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"Без погоды → MAE: {mae:.2f}, RMSE: {rmse:.2f}")
plot_forecast_compare(df_compare, "RandomForest без погоды")

import pandas as pd
import numpy as np
from datetime import timedelta
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# === Подготовка данных ===
df_all = df_kol.copy().sort_values('Дата').set_index('Дата').asfreq('D').fillna(0)
weather = weather_df.set_index('date').sort_index().asfreq('D').fillna(method='ffill')

# Создаём дополнительные признаки
df_all['dayofweek'] = df_all.index.dayofweek
df_all['month'] = df_all.index.month
df_all['rolling_7'] = df_all['Продажи'].rolling(7).mean().shift(1)  # скользящее среднее

# Объединяем с погодой
df_all['tavg'] = weather['tavg']
df_all['prcp'] = weather['prcp']

# === Train до марта ===
cutoff = pd.to_datetime('2025-03-01')
df_train = df_all[df_all.index < cutoff].copy()

# === Лаги ===
for lag in range(1, 8):
    df_train[f'lag_{lag}'] = df_train['Продажи'].shift(lag)

df_train = df_train.dropna()

# === Обучение ===
feature_cols = [f'lag_{i}' for i in range(1, 8)] + ['tavg', 'prcp', 'dayofweek', 'month', 'rolling_7']
X_train = df_train[feature_cols]
y_train = df_train['Продажи']

rf = RandomForestRegressor(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

# === Прогноз по дням на март ===
last_lags = df_all.loc[:cutoff - timedelta(days=1)]['Продажи'].tail(7).tolist()
forecast_dates = pd.date_range('2025-03-01', '2025-03-31')
predictions = []

dow = cutoff.dayofweek  # день недели 1 марта
month = 3  # месяц

for date in forecast_dates:
    row = {}

    # Лаги
    for i in range(1, 8):
        row[f'lag_{i}'] = last_lags[-i]

    # Погода
    row['tavg'] = weather.loc[date, 'tavg'] if date in weather.index else 0
    row['prcp'] = weather.loc[date, 'prcp'] if date in weather.index else 0

    # Временные признаки
    row['dayofweek'] = dow % 7
    row['month'] = month

    # Скользящее среднее
    row['rolling_7'] = np.mean(last_lags[-7:])

    # Предсказание
    X_input = pd.DataFrame([row])
    y_pred = rf.predict(X_input)[0]
    predictions.append((date, y_pred))

    # Обновление лагов
    last_lags.append(y_pred)
    dow += 1

# === Результат ===
df_forecast = pd.DataFrame(predictions, columns=['Дата', 'Прогноз']).set_index('Дата')
df_compare = df_all.loc['2025-03-01':'2025-03-31'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

# === Метрики и визуализация ===
mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"Модель (лаги + погода + день недели + скользящее среднее) → MAE: {mae:.2f}, RMSE: {rmse:.2f}")

plt.figure(figsize=(14, 5))
plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз', linestyle='--', marker='x')
plt.axvline(pd.to_datetime('2025-03-01'), color='black', linestyle=':', label='Старт прогноза')
plt.title('Прогноз продаж на март 2025 (RF + лаги + погода + день недели + среднее)')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np
from datetime import timedelta
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# === Подготовка данных ===
df_all = df_kol.copy().sort_values('Дата').set_index('Дата').asfreq('D').fillna(0)

# Временные признаки
df_all['dayofweek'] = df_all.index.dayofweek
df_all['month'] = df_all.index.month

# Train до 1 марта
cutoff = pd.to_datetime('2025-03-01')
df_train = df_all[df_all.index < cutoff].copy()

# Создание лагов
for lag in range(1, 8):
    df_train[f'lag_{lag}'] = df_train['Продажи'].shift(lag)
df_train = df_train.dropna()

# Обучение модели
feature_cols = [f'lag_{i}' for i in range(1, 8)] + ['dayofweek', 'month']
X_train = df_train[feature_cols]
y_train = df_train['Продажи']

rf = RandomForestRegressor(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

# === Прогноз на март 2025 ===
last_lags = df_all.loc[:cutoff - timedelta(days=1)]['Продажи'].tail(7).tolist()
forecast_dates = pd.date_range('2025-03-01', '2025-03-31')
predictions = []

dow = cutoff.dayofweek
month = 3

for date in forecast_dates:
    row = {f'lag_{i}': last_lags[-i] for i in range(1, 8)}
    row['dayofweek'] = dow % 7
    row['month'] = month

    X_input = pd.DataFrame([row])
    y_pred = rf.predict(X_input)[0]
    predictions.append((date, y_pred))

    last_lags.append(y_pred)
    dow += 1

# === Сравнение с фактом ===
df_forecast = pd.DataFrame(predictions, columns=['Дата', 'Прогноз']).set_index('Дата')
df_compare = df_all.loc['2025-03-01':'2025-03-31'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

# === Метрики и график ===
mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"Модель (лаги + день недели + месяц) → MAE: {mae:.2f}, RMSE: {rmse:.2f}")

plt.figure(figsize=(14, 5))
plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз', linestyle='--', marker='x')
plt.axvline(pd.to_datetime('2025-03-01'), color='black', linestyle=':', label='Старт прогноза')
plt.title('Прогноз продаж на март 2025 (лаги + день недели + месяц)')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np
from datetime import timedelta
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# === Подготовка данных ===
df_all = df_kol.copy().sort_values('Дата').set_index('Дата').asfreq('D').fillna(0)
weather = weather_df.set_index('date').sort_index().asfreq('D').fillna(method='ffill')

# Добавляем признаки
df_all['dayofweek'] = df_all.index.dayofweek
df_all['month'] = df_all.index.month
df_all['rolling_7'] = df_all['Продажи'].rolling(7).mean().shift(1)
df_all['tavg'] = weather['tavg']
df_all['prcp'] = weather['prcp']

# === Train до 1 января 2025 ===
cutoff = pd.to_datetime('2025-01-01')
df_train = df_all[df_all.index < cutoff].copy()

# Создание лагов
for lag in range(1, 8):
    df_train[f'lag_{lag}'] = df_train['Продажи'].shift(lag)
df_train = df_train.dropna()

# Обучение модели
feature_cols = [f'lag_{i}' for i in range(1, 8)] + ['tavg', 'prcp', 'dayofweek', 'month', 'rolling_7']
X_train = df_train[feature_cols]
y_train = df_train['Продажи']

rf = RandomForestRegressor(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

# === Прогноз на весь 2025 год ===
last_lags = df_all.loc[:cutoff - timedelta(days=1)]['Продажи'].tail(7).tolist()
forecast_dates = pd.date_range('2025-01-01', '2025-12-31')
predictions = []

dow = cutoff.dayofweek

for date in forecast_dates:
    row = {}

    # Лаги
    for i in range(1, 8):
        row[f'lag_{i}'] = last_lags[-i]

    # Погодные и календарные признаки
    row['tavg'] = weather.loc[date, 'tavg'] if date in weather.index else 0
    row['prcp'] = weather.loc[date, 'prcp'] if date in weather.index else 0
    row['dayofweek'] = dow % 7
    row['month'] = date.month
    row['rolling_7'] = np.mean(last_lags[-7:])

    # Предсказание
    X_input = pd.DataFrame([row])
    y_pred = rf.predict(X_input)[0]
    predictions.append((date, y_pred))

    # Обновление лагов
    last_lags.append(y_pred)
    dow += 1

# === Сравнение с реальностью ===
df_forecast = pd.DataFrame(predictions, columns=['Дата', 'Прогноз']).set_index('Дата')
df_compare = df_all.loc['2025-01-01':'2025-12-31'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

# === Метрики ===
mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"RandomForest → MAE: {mae:.2f}, RMSE: {rmse:.2f}")

# === График ===
plt.figure(figsize=(16, 6))
plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз', linestyle='--', marker='x', alpha=0.8)
plt.axvline(pd.to_datetime('2025-01-01'), color='black', linestyle=':', label='Старт прогноза')
plt.title('Прогноз продаж на 2025 год (RF + лаги + погода + день недели + среднее)')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

!pip install xgboost

import pandas as pd
import numpy as np
from datetime import timedelta
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_squared_error
from xgboost import XGBRegressor

# === Подготовка ===
df_all = df_kol.copy().sort_values('Дата').set_index('Дата').asfreq('D').fillna(0)
df_all['dayofweek'] = df_all.index.dayofweek
df_all['month'] = df_all.index.month

# Train до 01.01.2025
cutoff = pd.to_datetime('2025-01-01')
df_train = df_all[df_all.index < cutoff].copy()

# Лаги
for lag in range(1, 8):
    df_train[f'lag_{lag}'] = df_train['Продажи'].shift(lag)
df_train.dropna(inplace=True)

# Обучение
features = [f'lag_{i}' for i in range(1, 8)] + ['dayofweek', 'month']
X_train = df_train[features]
y_train = df_train['Продажи']

xgb = XGBRegressor(n_estimators=300, learning_rate=0.05, max_depth=6, random_state=42)
xgb.fit(X_train, y_train)

# === Прогноз на весь 2025 год ===
last_lags = df_all.loc[:cutoff - timedelta(days=1)]['Продажи'].tail(7).tolist()
forecast_dates = pd.date_range('2025-01-01', '2025-12-31')
predictions = []

dow = cutoff.dayofweek
month = cutoff.month

for date in forecast_dates:
    row = {f'lag_{i}': last_lags[-i] for i in range(1, 8)}
    row['dayofweek'] = dow % 7
    row['month'] = date.month  # динамически обновляется по календарю

    X_input = pd.DataFrame([row])
    y_pred = xgb.predict(X_input)[0]
    predictions.append((date, y_pred))

    last_lags.append(y_pred)
    dow += 1

# === Сравнение ===
df_forecast = pd.DataFrame(predictions, columns=['Дата', 'Прогноз']).set_index('Дата')
df_compare = df_all.loc['2025-01-01':'2025-12-31'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

# === Метрики ===
mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"XGBoost на 2025 → MAE: {mae:.2f}, RMSE: {rmse:.2f}")

# === График ===
plt.figure(figsize=(16, 6))
plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз (XGBoost)', linestyle='--', marker='x', alpha=0.7)
plt.axvline(pd.to_datetime('2025-01-01'), color='black', linestyle=':', label='Старт прогноза')
plt.title('Прогноз продаж на 2025 год (XGBoost + лаги + день недели + месяц)')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import pandas as pd

# === 1. Загрузка и парсинг данных продаж ===
file_path = "Продажи со складов 41175635.csv"
with open(file_path, 'r', encoding='utf-8') as f:
    lines = f.readlines()

raw_dates = lines[0].strip().split(';')
dates = [d for d in raw_dates if '-' in d]

# Автоматическое определение года
parsed_dates = []
current_year = 2021
last_month = 0

for d in dates:
    day, month = map(int, d.split('-'))
    if last_month == 12 and month == 1:
        current_year += 1
    try:
        dt = pd.to_datetime(f"{day}-{month}-{current_year}", dayfirst=True)
        parsed_dates.append(dt)
        last_month = month
    except:
        parsed_dates.append(None)

date_map = pd.Series(parsed_dates)

# Парсинг строк
parsed_data = []
for line in lines[1:]:
    parts = line.strip().split(';')
    warehouse = parts[0]
    values = parts[1:]
    for i in range(0, len(values) - 1, 2):
        index = i // 2
        if index < len(date_map):
            sales = values[i]
            stock = values[i + 1]
            parsed_data.append((warehouse, date_map[index], sales, stock))

# === 2. DataFrame по складам ===
df_wh = pd.DataFrame(parsed_data, columns=['Склад', 'Дата', 'Продажи', 'Остатки'])
df_wh = df_wh[df_wh['Склад'].isin(['Казань WB'])]
df_wh['Продажи'] = pd.to_numeric(df_wh['Продажи'], errors='coerce')
df_wh['Остатки'] = pd.to_numeric(df_wh['Остатки'], errors='coerce')
df_wh['Дата'] = pd.to_datetime(df_wh['Дата'])

# === 3. Цены из Excel ===
xls = pd.read_excel("WB - 41175635 - Продажи и остатки - 01.09.2021-17.04.2025 - (18.04.2025).xlsx", sheet_name="ag-grid")
xls['Дата'] = pd.to_datetime(xls['Дата'], errors='coerce')
xls = xls.rename(columns={'Цена с СПП, ₽': 'Цена с СПП'})

# === 4. Погода ===
weather_df = pd.read_csv('kazan.csv')
weather_df['date'] = pd.to_datetime(weather_df['date'], errors='coerce')
weather_df = weather_df.rename(columns={'date': 'Дата'})

# === 5. Объединение всего ===
df_merged = df_wh.merge(xls[['Дата', 'Цена с СПП']], on='Дата', how='left')
df_final_all = df_merged.merge(weather_df[['Дата', 'tavg', 'prcp']], on='Дата', how='left')

# === Результат ===
print(df_final_all.head())

# (опционально)
# df_final_all.to_csv("итог_продажи_цена_погода.csv", index=False)

import pandas as pd
import numpy as np
from datetime import timedelta
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# === Подготовка данных ===
df_all = df_final_all.copy().sort_values('Дата').set_index('Дата').asfreq('D').fillna(method='ffill')

# Добавляем признаки
df_all['dayofweek'] = df_all.index.dayofweek
df_all['month'] = df_all.index.month
df_all['rolling_7'] = df_all['Продажи'].rolling(7).mean().shift(1)

# === Train до 1 января 2025 ===
cutoff = pd.to_datetime('2025-01-01')
df_train = df_all[df_all.index < cutoff].copy()

# Создание лагов
for lag in range(1, 8):
    df_train[f'lag_{lag}'] = df_train['Продажи'].shift(lag)
df_train = df_train.dropna()

# === Обучение модели ===
feature_cols = (
    [f'lag_{i}' for i in range(1, 8)] +
    ['tavg', 'prcp', 'dayofweek', 'month', 'rolling_7', 'Цена с СПП']
)

X_train = df_train[feature_cols]
y_train = df_train['Продажи']

rf = RandomForestRegressor(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

# === Прогноз на весь 2025 год ===
last_lags = df_all.loc[:cutoff - timedelta(days=1)]['Продажи'].tail(7).tolist()
forecast_dates = pd.date_range('2025-01-01', '2025-12-31')
predictions = []

dow = cutoff.dayofweek

for date in forecast_dates:
    row = {}

    for i in range(1, 8):
        row[f'lag_{i}'] = last_lags[-i]

    # Погодные и календарные признаки
    row['tavg'] = df_all.loc[date, 'tavg'] if date in df_all.index else 0
    row['prcp'] = df_all.loc[date, 'prcp'] if date in df_all.index else 0
    row['dayofweek'] = dow % 7
    row['month'] = date.month
    row['rolling_7'] = np.mean(last_lags[-7:])

    # Цена
    row['Цена с СПП'] = df_all.loc[date, 'Цена с СПП'] if date in df_all.index else np.nan

    X_input = pd.DataFrame([row])
    y_pred = rf.predict(X_input.fillna(method='ffill'))[0]
    predictions.append((date, y_pred))

    last_lags.append(y_pred)
    dow += 1

# === Сравнение с реальностью ===
df_forecast = pd.DataFrame(predictions, columns=['Дата', 'Прогноз']).set_index('Дата')
df_compare = df_all.loc['2025-01-01':'2025-03-31'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

# === Метрики ===
mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"RandomForest с учётом цены → MAE: {mae:.2f}, RMSE: {rmse:.2f}")

# === График ===
plt.figure(figsize=(16, 6))
plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз', linestyle='--', marker='x', alpha=0.8)
plt.axvline(pd.to_datetime('2025-01-01'), color='black', linestyle=':', label='Старт прогноза')
plt.title('Прогноз продаж на 2025 год (с учётом цены с СПП)')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np
from datetime import timedelta
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# === Подготовка данных ===
df_all = df_final_all.copy().sort_values('Дата').set_index('Дата').asfreq('D').fillna(method='ffill')

# Добавляем признаки
df_all['dayofweek'] = df_all.index.dayofweek
df_all['month'] = df_all.index.month
df_all['rolling_7'] = df_all['Продажи'].rolling(7).mean().shift(1)

# === Train до 1 января 2025 ===
cutoff = pd.to_datetime('2025-01-01')
df_train = df_all[df_all.index < cutoff].copy()

# Создание лагов
for lag in range(1, 8):
    df_train[f'lag_{lag}'] = df_train['Продажи'].shift(lag)
df_train = df_train.dropna()

# Обучение модели
feature_cols = (
    [f'lag_{i}' for i in range(1, 8)] +
    ['tavg', 'prcp', 'dayofweek', 'month', 'rolling_7', 'Цена с СПП']
)
X_train = df_train[feature_cols]
y_train = df_train['Продажи']

rf = RandomForestRegressor(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

# === Прогноз на январь-февраль 2025 ===
last_lags = df_all.loc[:cutoff - timedelta(days=1)]['Продажи'].tail(7).tolist()
forecast_dates = pd.date_range('2025-01-01', '2025-02-28')
predictions = []

dow = cutoff.dayofweek

for date in forecast_dates:
    row = {}

    for i in range(1, 8):
        row[f'lag_{i}'] = last_lags[-i]

    row['tavg'] = df_all.loc[date, 'tavg'] if date in df_all.index else 0
    row['prcp'] = df_all.loc[date, 'prcp'] if date in df_all.index else 0
    row['dayofweek'] = dow % 7
    row['month'] = date.month
    row['rolling_7'] = np.mean(last_lags[-7:])
    row['Цена с СПП'] = df_all.loc[date, 'Цена с СПП'] if date in df_all.index else np.nan

    X_input = pd.DataFrame([row])
    y_pred = rf.predict(X_input.ffill())[0]

    predictions.append((date, y_pred))

    last_lags.append(y_pred)
    dow += 1

# === Сравнение с фактами ===
df_forecast = pd.DataFrame(predictions, columns=['Дата', 'Прогноз']).set_index('Дата')
df_compare = df_all.loc['2025-01-01':'2025-02-28'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

# === Метрики ===
mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"Прогноз на январь–февраль 2025 → MAE: {mae:.2f}, RMSE: {rmse:.2f}")

# === График ===
plt.figure(figsize=(14, 5))
plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз', linestyle='--', marker='x', alpha=0.8)
plt.axvline(pd.to_datetime('2025-01-01'), color='black', linestyle=':', label='Старт прогноза')
plt.title('Прогноз продаж на январь–февраль 2025 (с ценой, погодой, лагами)')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

MAE = 5.98 означает, что в среднем модель ошибается на 6 единиц продаж в день.

RMSE = 6.72 — чуть выше, что говорит о наличии нескольких "прыжков" или всплесков, где модель ошиблась сильнее обычного (например, выходной, акция и т.д.).

# Только числовые признаки
df_corr = df_all[['Продажи', 'tavg', 'prcp', 'Цена с СПП', 'dayofweek', 'month', 'rolling_7']].copy()

# Удалим пропуски
df_corr = df_corr.dropna()

# Корреляционная матрица
corr_matrix = df_corr.corr()

# Печать корреляции продаж с другими
print(corr_matrix['Продажи'].sort_values(ascending=False))

"""rolling_7 (скользящее среднее): сильная прямая зависимость — чем выше недавние продажи, тем выше текущие.

tavg (температура): умеренная связь — чем теплее, тем больше продаж.

Цена с СПП: слабо положительно влияет — снижение цены может стимулировать спрос.

prcp, dayofweek: почти не влияют линейно, могут давать слабый эффект или нелинейный.
"""

importances = rf.feature_importances_
features = X_train.columns

# Вывод по убыванию важности
feature_importance = pd.Series(importances, index=features).sort_values(ascending=False)
print(feature_importance)

"""lag_1 — самая важная фича, предсказание сильно зависит от вчерашнего спроса.

dayofweek, tavg — значимые: модель улавливает циклы по дням и температурные эффекты.

Цена с СПП: влияет, но не критично — скорее работает в паре с другими фичами.

month, prcp: почти не нужны — либо их влияние слабо, либо шумовое
"""

import pandas as pd
import numpy as np
from datetime import timedelta
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error

# === Подготовка данных ===
df_all = df_final_all.copy().sort_values('Дата').set_index('Дата').asfreq('D').ffill()

# Добавляем признаки
df_all['dayofweek'] = df_all.index.dayofweek
df_all['month'] = df_all.index.month
df_all['rolling_7'] = df_all['Продажи'].rolling(7).mean().shift(1)

# === Train до 1 января 2024 ===
cutoff = pd.to_datetime('2024-01-01')
df_train = df_all[df_all.index < cutoff].copy()

# Создание лагов
for lag in range(1, 8):
    df_train[f'lag_{lag}'] = df_train['Продажи'].shift(lag)
df_train = df_train.dropna()

# Обучение модели
feature_cols = (
    [f'lag_{i}' for i in range(1, 8)] +
    ['tavg', 'prcp', 'dayofweek', 'month', 'rolling_7', 'Цена с СПП']
)
X_train = df_train[feature_cols]
y_train = df_train['Продажи']

rf = RandomForestRegressor(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

# === Прогноз на весь 2024 год ===
last_lags = df_all.loc[:cutoff - timedelta(days=1)]['Продажи'].tail(7).tolist()
forecast_dates = pd.date_range('2024-01-01', '2024-12-31')
predictions = []

dow = cutoff.dayofweek

for date in forecast_dates:
    row = {}

    for i in range(1, 8):
        row[f'lag_{i}'] = last_lags[-i]

    row['tavg'] = df_all.loc[date, 'tavg'] if date in df_all.index else 0
    row['prcp'] = df_all.loc[date, 'prcp'] if date in df_all.index else 0
    row['dayofweek'] = dow % 7
    row['month'] = date.month
    row['rolling_7'] = np.mean(last_lags[-7:])
    row['Цена с СПП'] = df_all.loc[date, 'Цена с СПП'] if date in df_all.index else np.nan

    X_input = pd.DataFrame([row])
    y_pred = rf.predict(X_input.ffill())[0]

    predictions.append((date, y_pred))

    last_lags.append(y_pred)
    dow += 1

# === Сравнение с фактами ===
df_forecast = pd.DataFrame(predictions, columns=['Дата', 'Прогноз']).set_index('Дата')
df_compare = df_all.loc['2024-01-01':'2024-12-31'][['Продажи']].copy()
df_compare['Прогноз'] = df_forecast['Прогноз']

# === Метрики ===
mae = mean_absolute_error(df_compare['Продажи'], df_compare['Прогноз'])
rmse = np.sqrt(mean_squared_error(df_compare['Продажи'], df_compare['Прогноз']))
print(f"Прогноз на 2024 год → MAE: {mae:.2f}, RMSE: {rmse:.2f}")

# === Визуализация ===
plt.figure(figsize=(16, 6))
plt.plot(df_compare.index, df_compare['Продажи'], label='Факт')
plt.plot(df_compare.index, df_compare['Прогноз'], label='Прогноз', linestyle='--', marker='x', alpha=0.8)
plt.axvline(pd.to_datetime('2024-01-01'), color='black', linestyle=':', label='Старт прогноза')
plt.title('Прогноз продаж на 2024 год (с лагами, погодой, ценой с СПП)')
plt.xlabel('Дата')
plt.ylabel('Продажи')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()